# 逃逸分析

## 逃逸分析的好处

    最大的好处应该是减少 gc 的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要 gc 标记清除。
    因为逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好
    同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。

    go 在一定程度消除了堆和栈的区别，因为 go 在编译的时候进行逃逸分析，来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。

## 开启逃逸分析

    开启逃逸分析日志很简单，只要在编译的时候加上-gcflags '-m'，但是我们为了不让编译时自动内连函数，一般会加-l参数，最终为-gcflags '-m -l'

- [Golang 逃逸分析](https://gocn.vip/article/355)
- [Go 语言机制之逃逸分析(Language Mechanics On Escape Analysis)](https://studygolang.com/articles/12444)

## GC 优化

- [golang gc 优化思路以及实例分析](https://www.cnblogs.com/gao88/p/9850235.html)

1，函数尽量不要返回 map， slice 对象, 这种频繁调用的函数会给 gc 带来压力。

2，小对象要合并。

3，函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好。

4，避不开，能用 sync.Pool 就用，虽然有人说 1.10 后不推荐使用 sync.Pool，但是压测来看，确实还是有效果，堆累计分配大小能减少一半以上。

5，类型转换要注意，官方用法消耗特别大，推荐使用雨痕的方式。

6，避免反复创建 slice。
